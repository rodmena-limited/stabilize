#!/usr/bin/env python3
"""
Test scenarios generated by LLM from the stabilize prompt.

This script:
1. Sends the stabilize prompt to Ollama
2. Asks it to generate workflow scenarios
3. Executes each scenario to verify correctness
4. Reports any issues that need prompt clarification
"""

import json
import os
import subprocess
import sys
import tempfile
import traceback
from pathlib import Path

# Get the prompt text
from stabilize.cli.prompt_text import PROMPT_TEXT


def call_ollama(prompt: str, model: str = "glm-4.7:cloud") -> str:
    """Call Ollama API and return response."""
    import urllib.request

    payload = {
        "model": model,
        "prompt": prompt,
        "stream": False,
        "options": {
            "temperature": 0.3,  # Lower temperature for more consistent code
        },
    }

    req = urllib.request.Request(
        "http://localhost:11434/api/generate",
        data=json.dumps(payload).encode("utf-8"),
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    with urllib.request.urlopen(req, timeout=300) as response:
        result = json.loads(response.read().decode("utf-8"))
        return result.get("response", "")


def extract_python_code(text: str) -> list[str]:
    """Extract Python code blocks from LLM response."""
    codes = []
    in_code = False
    current_code = []

    for line in text.split("\n"):
        if line.strip().startswith("```python"):
            in_code = True
            current_code = []
        elif line.strip() == "```" and in_code:
            in_code = False
            if current_code:
                codes.append("\n".join(current_code))
        elif in_code:
            current_code.append(line)

    return codes


def run_scenario(code: str, scenario_name: str, timeout: int = 60) -> dict:
    """Run a scenario and return results."""
    # Create temp file
    with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
        f.write(code)
        temp_path = f.name

    try:
        result = subprocess.run(
            [sys.executable, temp_path],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=str(Path(__file__).parent.parent),
        )

        return {
            "scenario": scenario_name,
            "success": result.returncode == 0,
            "returncode": result.returncode,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "code": code,
        }
    except subprocess.TimeoutExpired:
        return {
            "scenario": scenario_name,
            "success": False,
            "returncode": -1,
            "stdout": "",
            "stderr": "TIMEOUT",
            "code": code,
        }
    except Exception as e:
        return {
            "scenario": scenario_name,
            "success": False,
            "returncode": -1,
            "stdout": "",
            "stderr": str(e),
            "code": code,
        }
    finally:
        os.unlink(temp_path)


# Scenarios to test - each is a prompt asking for a specific workflow type
SCENARIO_PROMPTS = [
    {
        "name": "basic_sequential",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a simple 3-stage sequential workflow (A -> B -> C)
2. Each stage uses ShellTask to echo a message
3. Stage B should use the output from stage A
4. Runs the workflow and prints the final status

Include ALL imports, setup code, and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "parallel_diamond",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a diamond pattern workflow: A -> (B, C in parallel) -> D
2. Stage A echoes "start"
3. Stages B and C run in parallel after A
4. Stage D waits for both B and C, then echoes their combined outputs
5. Uses ShellTask for all stages

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "http_task",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a 2-stage workflow
2. Stage 1 uses HTTPTask to GET https://httpbin.org/json (with parse_json=True)
3. Stage 2 uses ShellTask to echo the status code from stage 1
4. Runs the workflow and prints results

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "python_task_chained",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a 2-stage workflow using PythonTask
2. Stage 1 uses PythonTask with an inline script that calculates sum of [1,2,3,4,5] and sets RESULT={"sum": 15}
3. Stage 2 uses PythonTask to read the RESULT from stage 1 (remember: access via INPUT["result"]) and double the sum
4. Runs the workflow and prints final outputs showing the doubled value

IMPORTANT: Remember that PythonTask RESULT becomes "result" key in outputs, so stage 2 must access INPUT["result"]["sum"]

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "error_handling",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a custom Task that returns TaskResult.failed_continue() with an error message
2. Creates a 2-stage workflow where stage 1 uses this failing task
3. Stage 2 should still run because we used failed_continue (not terminal)
4. Runs the workflow and verifies both stages completed

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "retryable_task",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a RetryableTask that returns TaskResult.running() twice, then TaskResult.success()
2. Uses a counter in stage.context to track attempts
3. Creates a single-stage workflow using this task
4. Runs the workflow and verifies it succeeds after retries

Include ALL imports (including timedelta) and the main() function.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "wide_parallel",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a wide parallel workflow with 5 stages running in parallel (no dependencies on each other)
2. Each stage uses ShellTask to echo its stage number
3. Runs the workflow and prints all stage outputs

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "mixed_tasks",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a 3-stage workflow mixing different task types:
   - Stage 1: ShellTask that echoes "hello"
   - Stage 2: PythonTask that reads stdout from stage 1 and sets RESULT={"message": uppercase_stdout}
   - Stage 3: ShellTask that echoes the message from stage 2's result (access via {result} placeholder)
2. Runs the workflow and prints final outputs

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "terminal_error",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a custom Task that returns TaskResult.terminal(error="Fatal error occurred")
2. Creates a 2-stage workflow where stage 1 uses this terminal task
3. Stage 2 should NOT run because terminal halts the pipeline
4. Runs the workflow and verifies the final status is TERMINAL and stage 2 did not run

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "complex_diamond",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a complex DAG:
   A -> B, C (parallel)
   B -> D
   C -> D, E (parallel after C)
   D, E -> F (join)
2. Each stage uses ShellTask to echo its ref_id
3. Runs the workflow and verifies all stages complete in correct order

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
    {
        "name": "shell_with_special_chars",
        "prompt": """Based on the Stabilize documentation above, create a COMPLETE, RUNNABLE Python script that:
1. Creates a 2-stage workflow using ShellTask
2. Stage 1 echoes a JSON string: {"key": "value", "num": 123}
3. Stage 2 echoes the stdout from stage 1 (be careful with shell escaping!)
4. Runs the workflow and prints the final outputs

Include ALL imports and the main() function. The script must be self-contained and runnable.
Output ONLY the Python code in a ```python code block.""",
    },
]


def main():
    """Run all scenario tests."""
    print("=" * 70)
    print("STABILIZE PROMPT VALIDATION TEST")
    print("=" * 70)
    print("\nUsing Ollama model: glm-4.7:cloud")
    print(f"Testing {len(SCENARIO_PROMPTS)} scenarios\n")

    results = []

    for i, scenario in enumerate(SCENARIO_PROMPTS, 1):
        print(f"\n{'=' * 70}")
        print(f"SCENARIO {i}/{len(SCENARIO_PROMPTS)}: {scenario['name']}")
        print("=" * 70)

        # Build the full prompt
        full_prompt = f"""You are a Python developer using the Stabilize workflow engine.

Here is the complete documentation:

{PROMPT_TEXT}

---

TASK:
{scenario["prompt"]}

IMPORTANT RULES:
- Use disk-based SQLite: sqlite:///./test_{scenario["name"]}.db (NEVER use :memory:)
- Include ALL 12 handlers including JumpToStageHandler
- Set stage_start=True and stage_end=True on all tasks
- Use requisite_stage_ref_ids for dependencies
- Make the script completely self-contained
"""

        print("Calling Ollama...")
        try:
            response = call_ollama(full_prompt)
            print(f"Response received ({len(response)} chars)")

            # Extract code
            codes = extract_python_code(response)
            if not codes:
                print("ERROR: No Python code block found in response")
                print("Response preview:", response[:500])
                results.append(
                    {
                        "scenario": scenario["name"],
                        "success": False,
                        "error": "No code block in response",
                        "response": response[:1000],
                    }
                )
                continue

            code = codes[0]
            print(f"Extracted code ({len(code)} chars)")

            # Save code for inspection
            code_path = f"/tmp/scenario_{scenario['name']}.py"
            with open(code_path, "w") as f:
                f.write(code)
            print(f"Code saved to: {code_path}")

            # Run the scenario
            print("Running scenario...")
            result = run_scenario(code, scenario["name"])
            results.append(result)

            if result["success"]:
                print("✓ SUCCESS")
                if result["stdout"]:
                    print(f"Output: {result['stdout'][:500]}")
            else:
                print(f"✗ FAILED (exit code: {result['returncode']})")
                if result["stderr"]:
                    print(f"Error: {result['stderr'][:1000]}")

        except Exception as e:
            print(f"ERROR: {e}")
            traceback.print_exc()
            results.append(
                {
                    "scenario": scenario["name"],
                    "success": False,
                    "error": str(e),
                }
            )

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    passed = sum(1 for r in results if r.get("success"))
    failed = len(results) - passed

    print(f"\nPassed: {passed}/{len(results)}")
    print(f"Failed: {failed}/{len(results)}")

    if failed > 0:
        print("\nFailed scenarios:")
        for r in results:
            if not r.get("success"):
                print(f"  - {r['scenario']}: {r.get('stderr', r.get('error', 'Unknown error'))[:200]}")

    # Save full results
    with open("/tmp/prompt_test_results.json", "w") as f:
        # Remove code from results for readability
        clean_results = []
        for r in results:
            clean_r = {k: v for k, v in r.items() if k != "code"}
            clean_results.append(clean_r)
        json.dump(clean_results, f, indent=2)
    print("\nFull results saved to: /tmp/prompt_test_results.json")

    return 0 if failed == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
